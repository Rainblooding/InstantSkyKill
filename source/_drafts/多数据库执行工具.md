---
abbrlink: ''
categories:
- - java
- - 项目
date: '2025-07-29T21:56:43.140032+08:00'
tags:
- jdbc
- mysql
- h2
- log
title: 多数据库执行工具
updated: '2025-07-29T21:56:43.697+08:00'
---
> 背景：由于公司的项目属性经常会在本地搭建多个针对不同客户的测试环境。当修改表字段时要同时修改很多个库，当库多到一定程度时这真的会是一个比较麻烦的过程，所以诞生了这个项目。

同时在多个库中执行sql语句


<!-- more -->

# 初期设想

由于工作中主要涉及的是mysql数据库，所以设计的思路以及代码实现都是以mysql为目标工作环境。

我们知道单个`mysql`中实际上是存在多个库的，如`mysql`服务器`192.168.1.20:3306`上可以同时存在`test`、`work`等库。在我的设计中`sql`的最小执行单位是库，也就是上面提到的`test`、`work`等。将不同的库放进一个组中，选择某个组执行`sql`会将组内的所有库都执行一遍`sql`。

```sql
-- 服务器
DROP TABLE IF EXISTS server_config;
CREATE TABLE server_config (
                               id BIGINT AUTO_INCREMENT PRIMARY KEY,
                               name VARCHAR(100) NOT NULL,
                               db_type VARCHAR(50) NOT NULL,
                               host VARCHAR(255) NOT NULL,
                               port INT,
                               username VARCHAR(100),
                               password VARCHAR(255),
                               jdbc_url VARCHAR(500),
                               driver_class VARCHAR(255),
                               status CHAR(1) DEFAULT '1',
                               remarks VARCHAR(500),
                               created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                               updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 分组
DROP TABLE IF EXISTS db_group;
CREATE TABLE db_group (
                          id BIGINT AUTO_INCREMENT PRIMARY KEY,
                          name VARCHAR(100) NOT NULL,
                          description VARCHAR(255),
                          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 分组匹配
DROP TABLE IF EXISTS db_group_alias;
CREATE TABLE db_group_alias (
                                id BIGINT AUTO_INCREMENT PRIMARY KEY,
                                group_id BIGINT NOT NULL,
                                name VARCHAR(100) NOT NULL,
                                description VARCHAR(255),
                                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- 插入一些数据库配置
INSERT INTO server_config (
    name, db_type, host, port, username, password, jdbc_url, driver_class, status, remarks
) VALUES
      ('2', 'MySQL', '192.168.1.2', 3306, 'user', 'password',
       'jdbc:mysql://192.168.0.2:3306', 'com.mysql.cj.jdbc.Driver', '1', '正式使用'),
      ('4', 'MySQL', '192.168.0.4', 3306, 'user', 'hfwy_3185558',
       'jdbc:mysql://192.168.0.4:3306', 'com.mysql.cj.jdbc.Driver', '1', '正式使用');

-- 插入示例数据
INSERT INTO db_group (
    name, description
) VALUES
      ('test', '测试库'),
      ('oa', 'OA库');

INSERT INTO db_group_alias (
    group_id, name, description
) VALUES
      (1, 'test', '测试库'),
      (2, 'work', 'OA库'),
      (2, 'oa', 'OA库'),
      (2, 'bg', 'OA库');


```

`server_config`用来存储`mysql`服务器配置信息，`db_group`用来给库分组，`db_group_alias`用来根据关键字将服务器上的库分配到组中。我并没有使用完全的库名进行分组，因为这样实在是太麻烦了，同时`db_group_alias`会对`server_config`中每个配置都匹配进而分配到组里，`db_group_alias`没有进行服务器的区分，而是对所有的库进行配置的。

# 简单实现

## 1. 查询`db_group`下的`db_group_alias`

```java
jdbcTemplate.query("select * from DB_GROUP_ALIAS where group_id=?", new BeanPropertyRowMapper<>(DbGroupAlias.class), groupId)
```

## 2.根据`db_group_alias`匹配对应的库

```java
for(DbGroupAlias alias : DbGroupAliasList) {

}
```
